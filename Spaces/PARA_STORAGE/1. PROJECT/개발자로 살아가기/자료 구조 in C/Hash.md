
## Ein. What is Hash?
- Concept : 우리가 특정한 규칙을 바탕으로 값이 저장되는 위치를 정한다 -> 그러면 나중에 찾기 쉽다!
- Characteristic
	- 단방향 동작(Value로 key를 알기 어렵다)
	- 키 자체가 해시 함수에 의해 값이 있는 인덱스가 되므로 값을 찾기 위한 탐색 과정이 필요 없다. -> O(n) -> O(1)
	- 값을 인덱스로 활용하려면 적절한 변환 과정이 필요.
- Mean of the words at 'hast'
	- hash table : 키와 대응한 값이 저장되어 있는 공간
	- bucket : 해시 테이블의 각 데이터

## Zwei. Hash Function
#### 해시 함수를 구현할 때 고려할 내용
1. 해시 함수의 반환값이 해시 테이블의 크기를 넘으면 안된다.
2. 해시 함수의 변환 값의 충돌은 최대한 적게.
	- 충돌 : 서로 다른 두 키에 대해 해싱 함수를 적용한 결과가 동일한 경우를 지칭
	- 충돌이 아예 발생하지 않는 해시 함수는 거의 없음.

#### 자주 사용하는 해시 함수
- ##### 나눗셈법(Division Method)
	- h(x) = x mod m
	- x는 key / / m = prime number
		- 왜 소수를 사용?
			- 충돌이 적게 발생하기 때문에.
			- Proof
			- 임의의 수 N, M, K가 존재할 때, M은 N의 약수 중 하나라고 하자. 그렇다면 M * K = N이 되는 수가 반드시 존재함.
			- Zum Beispiel : N = 15, M = 3. Then, K = 5. -> 5을 주기로 같은 해시값이 반복됨.
	- 해시값 범위 : 0 ~ (k - 1)
		- 이에 따라 단점이 발생.-> 큰 수를 다루기 위해서는 자연스레 큰 소수를 구해야함!!
		- 그러나 소수를 찾는 효율적인 알고리즘은 아직 존재 X. So, 시간이 많이 걸리는 단점이...ㅠ
- ##### 곱셈법(Multiplcation method)
	- 나눗셈법처럼 mod 연산 하지만 소수는 활용하지 않음 -> 단점 때문에!
	- h(x) = (((x * A) mod 1) * m)
		- m = 최대 버킷의 개수
		- A = 황금비
			- 무한소수. 1.6180339887....
	- *STEP*
		- 1. 키 * 황금비
		- 2. 1의 값 mod 1. 
			- 소수 부분만 사용하기 위해서.
		- 3. 테이블 위치 = '2의 값' * m(최대 버킷의 개수)
			- '2의 값' = 0.xxxx. So, m을 곱한 값 -> 0  ~ (m - 1)
- ##### 문자열 해싱
	- 키의 자료형이 문자열일 때도 사용할 수 있는 해시 함수.
	- 과정
		- 문자열의 문자 -> 숫자
		- 숫자 -> 다항식 값
		- 공식
			- $$ hash(S) = (s[0] + s[1] * p + s[2]*p^2 ...s[n-1]*p^(n-1))\; mod\; m $$
			- p = 31 (메르센 소수) & m : 해시 테이블 최대 크기
				- 메르센 소수란?
					- $$2^N - 1$$
					- 의 형식으로 표시할 수 있는 숫자 중 소수인 수.
					- 메르센 소수가 해시에서 충돌을 줄이는데 효과적이라는 연구 결과 존재.
		- 단점 : 해시 함수를 적용한 값이 해시 테이블 크기에 비해 지나치게 클 수 있음.
	- 수정 공식
	- $$hash(S) = (s[0]\%m + s[1]*p\%m + s[2]*p^2\%m ...s[n-1]*p^(n-1)\%m)\;\%\;m$$
	- 
	- 응용된 개념
	- $$(a+b)\%c = (a\%c + b\%c)\%c$$
## Drei : 충돌 처리
- 하나의 버킷에 2개의 값을 넣을 수 없음. -> 반드시 처리해줘야함.
### HOW?
- ##### 체이닝으로 처리하기
	- 충돌이 발생하면 해당 버킷에 linked list로 같은 해시값을 가지는 데이터 연결
	- 장점
		- 편함
	- 단점
		- 해시 테이블 공간 활용성 저하. -> Ohne C
		- 검색 성능 저하
			- worst case = all key make confliction -> Then O(n)
- ##### 개방 주소법으로 처리학
	- 빈 버킷을 찾아 충돌값을 삽입
	- 메모리를 더 효율적으로 사용
		- **Then, How**
		- *선형 탐사 방식(linear probing)*
			- 충동 발생 시 다른 빈 버킷을 찾을 때까지 일정한 가격으로 이동.
			- 수식
			- $$h(k, i) = (h(k) + i)\% m$$
			- m = 수용할 수 있는 최대 버킷 
			- mod : 선형 탐사 시 테이블의 범위를 넘으면 안되므로 사용
			- 단점 : 충돌 발생 시 1칸씩 이동하며 해시 테이블 빈 곳에 값을 넣으면 해시 충돌이 발생한 값끼리 모이는 영역인 클러스터가 형성됨. 이런 군집 발생 시 해값 겹칠 확률 증가
				- 이를 방지하기 위해 제곱수만큼 이동하며 탐사하는 방법도 존재.
		- *이중 해싱 방식*
			- 해시 함수 2개를 사용. -> 때에 따라 N개로 증가.
			- 첫 번째 해시 함수로 충돌이 발생 -> 두 번째 해시 함수를 이용
				- 충돌이 발생한 지점을 기준으로 위치를 결정하는 역할
			- 수식
			- $$h(k, i) = (h_1(k) + i * h_2(k)) \% m$$
			- 더 하는 방식으로 데이터의 위치를 선정 -> but 클러스터를 줄이기 위해 m 을 제곱수로 하거나 소수로 결정 -> 주어지는 키마다 점프하는 위치를 해시 함수다르게 해서 클러스터 형성을 최대한 피하기 위함.