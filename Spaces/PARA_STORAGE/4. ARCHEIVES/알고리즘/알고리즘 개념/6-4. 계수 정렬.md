---
tags:
  - 이취코파_개념
---
<h4>개요</h4>
- 매우 빠른 정렬 알고리즘 ; 그러나, 특정한 조건이 부합할 때만 사용이 가능.
		<h6>특정한 조건</h6>
	- 데이터의 크기 범위가 제한되어 정수 형태로 표현할 수 있을 때
	- 일반적으로 가장 큰 데이터와 가장 작은 데이터의 차이가 1,000,000을 넘지 않을 때 효과적으로 사용 가능.

	- 계수 정렬을 이용할 때, 모든 범위를 담을 수 있는 크기의 리스트(배열)를 선언해야 하기 때문!


<h4>시간 복잡도</h4>
let, 데이터의 개수 = N, 최대값의 크기 = K.
then, O(N + K)  :  앞에서부터 데이터를 하나씩 확인하면서 리스트에서 적절한 인덱스의 값을 1씩 증가시키고, 리스트의 각 인덱스에 해당하는 값들을 확인할 때 데이터 중 최댓값의 크기만큼 반복을 수행해야 하기 때문.

- 매우 빠름 ;;

- 그러나, 0과 999,999 단 2개의 데이터만 있다면? -> 비효율;;
- 동일한 값을 가지는 데이터가 여러 개 등장할 때 적합.

- 퀵 정렬은 일반적인 경우에서 평균적으로 빠르게 작동하기 때문에 데이터의 특성을 파악하기 어렵다면 퀵 정렬을 이용하는 것이 유리.

<h4>각종 언어로 작성된 코드</h4>

```Python
# 모든 원소의 값이 0보다 크거나 같다고 가정

array = [7, 5, 9, 0, 3, 1, 6, 2, 9, 1, 4, 8, 0, 5, 2]

# 모든 범위를 포함하는 리스트 선언 (모든 값은 0으로 초기화)

count = [0] * (max(array) + 1)

  

for i in range(len(array)):

    count[array[i]] += 1 # 각 데이터에 해당하는 인덱스의 값 증가

  

for i in range(len(count)): # 리스트에 기록된 정렬 정보 확인

    for j in range(count[i]):

        print(i, end=' ') # 띄어쓰기를 구분으로 등장한 횟수만큼 인덱스 출력
```

```Java
import java.util.*;

  

public class Main {

    public static final int MAX_VALUE = 9;

  

    public static void main(String[] args) {

        int n = 15;

        // 모든 원소의 값이 0보다 크거나 같다고 가정

        int[] arr = {7, 5, 9, 0, 3, 1, 6, 2, 9, 1, 4, 8, 0, 5, 2};

        // 모든 범위를 포함하는 배열 선언(모든 값은 0으로 초기화)

        int[] cnt = new int[MAX_VALUE + 1];

  

        for (int i = 0; i < n; i++) {

            cnt[arr[i]] += 1; // 각 데이터에 해당하는 인덱스의 값 증가

        }

        for (int i = 0; i <= MAX_VALUE; i++) { // 배열에 기록된 정렬 정보 확인

            for (int j = 0; j < cnt[i]; j++) {

                System.out.print(i + " "); // 띄어쓰기를 기준으로 등장한 횟수만큼 인덱스 출력

            }

        }

    }

  

}
```

```cpp
#include <bits/stdc++.h>

#define MAX_VALUE 9

  

using namespace std;

  

int n = 15;

// 모든 원소의 값이 0보다 크거나 같다고 가정

int arr[15] = {7, 5, 9, 0, 3, 1, 6, 2, 9, 1, 4, 8, 0, 5, 2};

// 모든 범위를 포함하는 배열 선언(모든 값은 0으로 초기화)

int cnt[MAX_VALUE + 1];

  

int main(void) {

    for (int i = 0; i < n; i++) {

        cnt[arr[i]] += 1; // 각 데이터에 해당하는 인덱스의 값 증가

    }

    for (int i = 0; i <= MAX_VALUE; i++) { // 배열에 기록된 정렬 정보 확인

        for (int j = 0; j < cnt[i]; j++) {

            cout << i << ' '; // 띄어쓰기를 기준으로 등장한 횟수만큼 인덱스 출력

        }

    }

}
```