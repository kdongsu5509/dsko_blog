---
{"dg-publish":true,"permalink":"/spaces/para-storage/1-project/flutter/flutter-single-pass/"}
---

플러터의 제한 사항 중 하나로 자주 언급되는 "single pass"는 레이아웃 엔진이 한 번의 패스로 레이아웃을 계산하고 렌더링하는 방식을 의미합니다. 이는 플러터의 성능 최적화를 위한 중요한 개념입니다. 아래에 이 개념을 자세히 설명합니다.

### Single Pass Layout

#### 개념 설명

플러터의 레이아웃 시스템은 위젯 트리의 각 위젯을 한 번만 방문하여 크기와 위치를 결정합니다. 즉, 위젯 트리 전체를 한 번만 순회하여 레이아웃을 계산합니다. 이를 "single pass"라고 합니다. 이 과정은 크게 두 단계로 나뉩니다:

1. **측정 (Measure) 단계**: 각 위젯의 크기를 결정합니다.
2. **배치 (Layout) 단계**: 각 위젯의 위치를 결정합니다.

### 이유 및 장점

- **성능 최적화**: 위젯 트리를 여러 번 순회하지 않고 한 번의 패스로 레이아웃을 계산함으로써 성능을 최적화합니다. 이는 특히 복잡한 UI의 경우 중요한 성능 이점을 제공합니다.
- **일관성 유지**: 한 번의 패스로 레이아웃을 계산함으로써, 위젯의 크기와 위치가 일관되게 유지됩니다. 이는 레이아웃 결과의 예측 가능성을 높입니다.

### 제한 사항

하지만 "single pass" 방식은 몇 가지 제한 사항을 가져옵니다:

1. **순환 의존성 회피**: 레이아웃 계산 시 순환 의존성이 발생하지 않도록 해야 합니다. 예를 들어, 부모와 자식 위젯이 서로의 크기에 의존하는 경우 문제가 발생할 수 있습니다.
2. **복잡한 레이아웃의 구현 어려움**: 일부 복잡한 레이아웃은 한 번의 패스로 구현하기 어려울 수 있습니다. 이런 경우, 플러터는 커스텀 레이아웃 위젯을 제공하여 개발자가 직접 레이아웃 로직을 정의할 수 있게 합니다.
3. **크기 제한**: 부모 위젯이 자식 위젯의 크기에 따라 동적으로 크기를 변경해야 하는 경우, 이를 한 번의 패스로 처리하는 것이 어렵습니다. 이러한 경우, 제한적인 레이아웃 논리를 사용하거나 더 정교한 위젯을 만들어야 합니다.

### 예제

간단한 예제로, 한 번의 패스로 레이아웃을 계산하는 방식을 보여줍니다:

```dart
class SinglePassExample extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text('Single Pass Layout Example')),
      body: Center(
        child: Column(
          children: [
            Container(
              width: 100,
              height: 100,
              color: Colors.red,
            ),
            Container(
              width: 100,
              height: 100,
              color: Colors.blue,
            ),
          ],
        ),
      ),
    );
  }
}
```

위 예제에서, `Column` 위젯은 자식 위젯들의 크기를 한 번의 패스로 계산하고, 이를 기준으로 자식 위젯들을 배치합니다.

### 결론

플러터의 "single pass" 레이아웃 방식은 성능 최적화를 위한 중요한 개념으로, 위젯 트리를 한 번만 순회하여 레이아웃을 계산합니다. 이는 높은 성능과 일관성을 제공하지만, 일부 복잡한 레이아웃을 구현하는 데는 제한이 있을 수 있습니다. 이러한 제한을 극복하기 위해 플러터는 커스텀 레이아웃 위젯과 같은 도구를 제공하여 개발자가 필요한 레이아웃을 유연하게 구현할 수 있도록 합니다.