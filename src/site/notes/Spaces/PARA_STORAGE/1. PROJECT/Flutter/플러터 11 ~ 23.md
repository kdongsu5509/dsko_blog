---
{"dg-publish":true,"permalink":"/spaces/para-storage/1-project/flutter/11-23/"}
---

```toc
```
# 11. StatefulWidget
## StatefulWidet
**EveryThing is Widget**
- 플러터는 화면에 보여지는 요소를 클래스로 표현, 이를 위젯이라 명명
- 모든 위젯은 Immutable.
	- 그렇다면, 화면 내 변경은?? -> 덮어쓰기(by build())

**UI widget
- StatelessWidget
	-  `HotReload` 로 변경가능.
		- 그러나, 해당 기능은 개발 단계의 개발자만 볼 수 있음
- StatefulWidget
	-  `setstate(함수)` 함수를 이용해 상태 변경 가능.
- 형태 : 클래스 2개 필요. 둘이 연동되어 있음.
```Dart
class HomeScreen extends StatefulWidget{
	@Override
	State<HomeScreen> createState() => _HomeScreenState();
}

class _HomeScreenState extends State<HomeScreen> {
	~~~
}
```

+) 플러터 프레임워크는 최초로 앱을 실행시킬 때 2번 빌드를 실행함.
## 실습코드
```Dart
import 'package:flutter/material.dart';  
  
class HomeScreen2 extends StatefulWidget {  
  State<HomeScreen2> createState() => _HomeScreen2State();
  ///화살표 연산자(=>)
  ///반환 타입 : Sate<HomeScreen2>
	  ///State클래스 : StatefulWidget과 연결되어 위젯의 상태를 관리하고, 화면의 상태 변화에 따른 뷰의 업데이트를 담당 / build() 메서드를 포함하며, 이 메서드에서는 실제 위젯의 렌더링을 정의
}  
  
class _HomeScreen2State extends State<HomeScreen2>{  
  Color color = Colors.blue;  
  
  @override  
  Widget build(BuildContext context) {  
    return Scaffold(  
      body: Container(  
        width: double.infinity,  
        child: Column(  
          mainAxisAlignment: MainAxisAlignment.center,  
          children: [  
            ElevatedButton(  
              onPressed: () {  
                if(color == Colors.blue){  
                  color = Colors.red;  
                }else{  
                  color = Colors.blue;  
                }  
  
                print('color : $color');  
  
                setState(() {  
                  color = color;  
                });  
              },  
              child: Text('색상 변경!'),  
            ),  
            const SizedBox(height: 32),  
            Container(  
              width: 50.0,  
              height: 50.0,  
              color: color,  
            )  
          ],  
        ),  
      ),  
    );  
  }  
}
```



# 12. Widget Life Cycle
## StatelessWidget 라이프 사이클
- Step1 : Constructor() 호출 -> Step2 : Build() 호출 : 화면 생성.
### 실습코드
```dart
import 'package:flutter/material.dart';  
  
class HomeScreen extends StatelessWidget {  
  const HomeScreen({super.key});  
  
  @override  
  Widget build(BuildContext context) {  
    return Scaffold(  
      body: CodeFactoryWidget(),  
    );  
  }  
}  
  
class CodeFactoryWidget extends StatelessWidget {  
  CodeFactoryWidget({super.key}){  
    print('CodeFactoryWidget constructor');  
  }  
  
  @override  
  Widget build(BuildContext context) {  
    print('CodeFactoryWidget build');  
    return Container(  
      width: 50.0,  
      height: 50.0,  
      color: Colors.red,  
    );  
  }  
}
```

+) 위의 `CodeFactoryWidget` 의 생성자를 Const Constructor로 생성할 수 없는 이유.

- Const와 final의 차이.
	- const : 
	- final : 
- 그렇다면.... 코드는 const 대상일까? -> 답은 X
	- 코드는 JIT 컴파일.
		- 기본:  JIT(Just-In-Time) 컴파일러를 사용하여 코드를 실행 ; 코드를 필요에 따라 바로 컴파일하여 기계어로 변환
		- 하지만 `const`는 이 JIT 컴파일과는 다르게, 코드를 미리 컴파일할 때 이미 결정된 상수 값을 사용하여 최적화하는 것입니다.따라서 Dart에서 `const`는 컴파일 시간에 결정되고 최적화되는 상수 값들을 지정하는 데 사용됨.
## StatefulWidget 라이프 사이클
- **Type1**
![statefulWidgeLifeCycle.png](/img/user/Spaces/included%20image/statefulWidgeLifeCycle.png)
- CodeFactoryWidget -> `StatefulWidget`
-  `StatefulWidget` 위젯이 화면에 표시될 때 내부적으로 상태 클래스 (`State<T>`)가 생성되어 상태를 관리
	- 여기서 `T`는 해당 `StatefulWidget`의 타입
	- 상태 클래스는 위젯의 상태를 관리하고 상태가 변경될 때마다 화면을 다시 렌더링
###### StatefulWidget과 State 클래스의 관계
- StatefulWidget 역시 Widget -> 즉 immutable.
	- 그래서 상태를 관리할 수 있는 상태 객체(`state<T>`) 를 생성.
	- by createState().
- State(`T`)
	- `StatefulWidget`과 연결된 상태를 관리
	-  `setState` 메서드를 호출하여 UI를 갱신
	- `StatefulWidget`의 생명주기 동안 여러 번 생성되고 파괴될 수 있음.
	- -> 그것이 위의 라이프 사이클
		- 1. StatefulWidget이 생성
			- Contstructor()
			- createState()
		- 2. createState()를 통해 생성되는 `State<T>` 상태 객체.
			- initState() -> 일단 초기화
			- didChangeDependencies() --?
			- 현재 상태 : dirty (아직 build 안됨)
			- build() -> 
				- 여기서 setState()를 통해 다시 dirty로 변경할 수도 있다 -> Type2
			- 지금 상태 : clean(build 완료)
		- 3. 다 사용했으면 삭제.
			- deactivate()
			- dispose()



**Type2**
![stateset 라이프 사이클.png](/img/user/stateset%20%EB%9D%BC%EC%9D%B4%ED%94%84%20%EC%82%AC%EC%9D%B4%ED%81%B4.png)
- setState() 내 코드 실행은 dirty상태로 변경 전에 수행.

**Type3**
![lifecycle3_code.png](/img/user/Spaces/included%20image/lifecycle3_code.png)
- 구조
HomeScreen (StatefulWidget)
└── _HomeScreenState (State)
    └── GestureDetector
        └── onTap: () {
              setState(() {
                color = color == Colors.red ? Colors.blue : Colors.red;
              });
            }
        └── child: CodeFactoryWidget (StatefulWidget)
            └── _CodeFactoryWidgetState (State)
                └── Container
                    └── width: 50.0
                    └── height: 50.0
                    └── color: widget.color (Colors.red or Colors.blue)

- **상황**
	- HomeScreen.HomeScreenState.GestureDetector 내에서 setState()가 수행됨.
		- 따라서 build()가 재실행.
		- 이 때 build() 안에 CodeFactoryWidget이 존재!!
	- CodeFacotryWidget과 그의 상태 위젯은 이미 당연히 최초 build시에 build 완료됨.

**Logic
![lifecycle3.png](/img/user/lifecycle3.png)
- 일단 build()가 상위 class에 의해서 실행되면,
	- 다시 Constructor 실행
	- 이 때, 이미 기존 상태 위젯 존재하므로 createState() 미 이행.
		- 이미 존재하던 상태 위젯이므로 initState()랑 didChageDependencies()도 미이행.
	- didUpdateWidget() 실행 
	- 그런데, build() 기록은 새로 만들어진 내 기준에선 없으니 상태가 dirty.
		- 그래서 build() 후 상태 clean으로 변경.


---
---
---
# 13. Image Carousel (전자액자)
## Timer
- 지정한 시간이 지난 뒤 한 번 또는 주기적으로 무언가를 실행 할 수 있게 해주는 위젯
- dart:async(기본 제공) ; pubspec.yaml에서 설정 x

###### Single
```DART
import 'dart/async'

void maiN(){
	Timer(
		Duration(seconds : 1),
		() {
			print('1초 뒤 실행');
		}
	)
}
```
- 첫 번째 파라미터 : Duration
- 두 번째 파라미터 : 실행 함수.

+)추가 : Dart의 익명, 람다 함수
```dart
// 일반 익명 함수
var printMessage = (String message) {
  print(message);
};

// 람다 함수
var add = (int a, int b) => a + b;
```

###### Multi
```Dart
import 'dart/async'

void maiN(){
	Timer.periodic( //반복 실행 위해 .periodic 생성자 사용
		Duration(seconds : 1),
		(Timer timer) {
			print('1초 뒤 실행');
		}
	)
}
```
- 첫 번째 파라미터 : Duration
- 두 번째 파라미터 : 실행 함수.
	- 파라미터에 Timer timer 추가 -> 타이머의 인스턴스 반환
	- 반복 종료 조건을 위해.(timer.cancel)

Timer.canel() 예시
```dart
import 'dart:async';

void main() {
  
  int num = 0;
  
  Timer.periodic(
    Duration(seconds: 1),
    (Timer timer) {
      num++;
      print('1초 뒤에 실행한다!');
      
      if(num == 12){
        timer.cancel();
      }
    },
  );
}

```

## PageView을 이용한 코드
```Dart
import 'package:flutter/material.dart';  
  
class HomeScreen extends StatelessWidget {  
  const HomeScreen({super.key});  
  
  @override  
  Widget build(BuildContext context) {  
    return Scaffold(  
      body: PageView(  
        children: [1, 2, 3, 4, 5]  
            .map((e) => Image.asset(  
                  'asset/img/image_$e.jpeg',  
                  fit: BoxFit.cover,  
                ))  
            .toList(),  
      ),  
    );  
  }  
}
```
- PageView => [[Flutter_pageView]]

```dart
import 'package:flutter/material.dart';  
import 'dart:async';  
  
class HomeScreen extends StatefulWidget {  
  const HomeScreen({super.key});  
  
  @override  
  State<HomeScreen> createState() => _HomeScreenState();  
}  
  
class _HomeScreenState extends State<HomeScreen> {  
  Timer? timer;  
  
  PageController controller = PageController();  
  
  @override  
  void initState() {  
    // TODO: implement initState  
    super.initState();  
  
    timer = Timer.periodic(  
      Duration(seconds: 2),  
        (timer) {  
        int currentPage = controller.page!.toInt();  
        int nextPage = currentPage + 1;  
        if (nextPage > 4) {  
          nextPage = 0;  
        }  
  
        controller.animateToPage(  
          nextPage,  
          duration: Duration(milliseconds: 300),  
          curve: Curves.linear,  
        );  
      },  
    );  
  }  
  
  @override  
  void dispose() {  
    if (timer != null){  
      timer!.cancel();  
    }  
    controller.dispose();  
    super.dispose();  
  }  
  
  @override  
  Widget build(BuildContext context) {  
    return Scaffold(  
      body: PageView(  
        controller: controller,  
        children: [1, 2, 3, 4, 5]  
            .map((e) =>  
            Image.asset(  
              'asset/img/image_$e.jpeg',  
              fit: BoxFit.cover,  
            ))  
            .toList(),  
      ),  
    );  
  }  
}
```
-curve : [curve 관련 effect 보기](https://api.flutter.dev/flutter/animation/Curves-class.html)

[[Flutter_Controller]]

---
---
# 14. DateTime & Duration
- DateTime : 날짜(with time)표현 클래스
```Dart
void main(){
 final date = Datetime(
	 1992, 11,23,1,23,25,30,5
 )
}
```
- 년,월,일,시,분,초,밀리 초, 마이크로 초에 해당 되는 값들을 순서대로 입력.
- 년도만 필수, 나머지는 옵션
	- 월, 일 기본값 : 1
	- 그 외 : 0
- 프로그램이 실행되는 시스템 시간 기준.

```Dart
void main(){
 final date = Datetime.utc(
	 1992, 11,23,1,23,25,30,5
 )

 final utcDate = date.toUtc();
 final LocalDate = utcDate.toLoacal();
}
```
- utc 기준 시간. -> 뒤에 'Z' 붙음

```dart
void main() {
	final now = Duration.now();
}
```
- 컴파일 된 기준의 시간.



- Duration : 기간 표현 클래스
```dart
void main() {
	final duration = Duration(
	days: 1
	hours : 1,
	minutes : 1,
	seconds : 1,
	milliseconds : 1,
	microseconds: 1,
	)
}
```
- Named Parameter로 날, 시, 분, 초 , 밀리 초, 마이크로 초 입력 가능
- 값을 입력하지 않으면  모든 값은 0으로 초기화됨.

```dart
void main() {
  final date = DateTime(
    1992, 11, 23,
  );
  
  final duration = Duration(
    days: 1
  );
  
  print(date.add(duration));
}
```

```dart
void main() {
  final ein = DateTime(
    1992,
    11,
    23,
  );

  final zwei = DateTime(
    2023,
    11,
    23,
  );

  print(ein.isAfter(zwei)); //false
  print(ein.isBefore(zwei)); //true
  //isAtSameMomentAs() 도 존재.
}

```


---
---
# 15. U&I 우리 사귄지 몇일
- DateTime
- MediaQuery
- DatePicker
- 여러개의 위젯으로 분리
- 폰트 적용
- 테마 사용

## 폰트 에셋 파일 추가
- Google Font와 같은 사이트에서 찾아서 사용!


## 레이아웃 작업하기
SafeArea : 스카폴드
MediaQuery

## 디자인 마무리하기
Colors.pink[] // 100~900 : 낮을 수록 밝음
Text 위젯의 style : 스타일 지정 가능.
	-폰트 패밀리(이름, 문자열), 크기, 색상 등등 가능.


## 테마 적용해보기
- 직관성 좋게 유지
MaterialApp 위젯에서 `theme` 파라미터 사용
- textTheme, buttonTheme 등 존재.
	- 가이드 라인은 없음. 적절히 잘 사용할 것. -> 협업할 때 특히.


적용 : style: Theme.of(context).textTheme.테마이름.

## DatePicker 사용해보기
```dart
IconButton(  
  iconSize: 60,  
  color: Colors.red,  
  onPressed: () {  
    showCupertinoDialog(  
      context: context,  
      // Dialog 밖 클릭 시 닫히는 코드
      barrierDismissible: true,  
      builder: (BuildContext context) {  
        return Align( // 정렬이 없으면 전체 사이즈 차지함.  
          alignment: Alignment.center,  
          child: Container(  
            color: Colors.white,  
            height: 300,  
            child: CupertinoDatePicker(  
			  //Container로 공간 확보 후 child로 DatePicker 사용
              mode: CupertinoDatePickerMode.date,  
              //CupertinoDatePicker가 필요로 하는 핵심 파라미터
              //이것 역시 IDE에서 확인 후 추가함.
              onDateTimeChanged: (DateTime value) {  
                print(value);  
                // onDateTimeChanged : 반환함수
                // 이것도 부모 위젯에서 파악.
              },  
              dateOrder: DatePickerDateOrder.ymd,  // 입력 순서 변경
            )  
          ),  
        );  
      },  
    );  
  }
```
- Cupertion : 애플 본사 위치 : 그래서 애플 관련 위젯에는 `cupertino` 가 들어감.
- showCupertinoDialog까지만 생각해내고 다 부모 위젯을 보고 작성한 코드들
	- 이렇게 하지 않으면 코드를 작성할 수 가 없다. -> 위젯이 너무 많아..
- 원칙을 이해하고 직접 돌려보면서(build 된 코드의 변경인 경우에는 hot reload를 하면서 코드 작성해야함.
